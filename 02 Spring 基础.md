## Spring 基础

#### 1	谈谈什么是Spring？

Spring的核心是控制反转(IOC)和面向切面(AOP)。
简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式)轻量级开源框架。

#### 2	为什么要用Spring？

Spring创建对象的过程，不是在代码里面实现的，而是交给Spring来进行配置实现的。

#### 3	什么是Spring IOC容器？

Spring IOC指的是控制反转，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。交由Spring来管理这些，实现解耦.

#### 4	springIOC实现原理？

使用反射机制+XML技术
1，使用java反射机制，扫描包下面的所有类
2，判断类上面是否有注解
3，使用java反射机制实现初始化（java反射机制初始化，调用无参构造函数。）

#### 5	什么是SpringAOP？

面向切面编程解决代码复用问题。前置 后置 环绕 和 异常切面。

#### 6	Spring AOP技术原理？

代理设计模式，动态代理和静态代理。

#### 7	AOP技术的应用场景？

日志记录，性能统计，安全控制，事务处理，异常处理等等

#### 8	AOP技术底层实现原理？

代理设计模式

#### 9	动态代理与静态代理区别？

**静态代理**(静态定义代理类)：由程序员创建代理类生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了。在代码编译时，织入代理类，代理类已经存在。

**动态代理**(动态生成代理类)：在程序运行时运用反射机制动态创建而成。
Jdk自带动态代理，Cglib 、javaassist（字节码操作库）

#### 10	CGLIB底层使用什么技术？

利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。 

#### 11	Spring事务的分类？

编程事务：手动事务

声明事务：原理使用编程事务+注解+反射机制进行包装

#### 12	Spring事务传播行为？

Spring中**事务**的定义：
** Propagation**（key属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。）有以下选项可供使用：

***PROPAGATION_REQUIRED***—如果当前有事务，就用当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。

***PROPAGATION_SUPPORTS***--支持当前事务，如果当前没有事务，就以非事务方式执行。//如果外层方法没有事务，就会以非事务进行执行。

***PROPAGATION_MANDATORY***--支持当前事务，如果当前没有事务，就抛出异常。 

***PROPAGATION_REQUIRES_NEW***--新建事务，如果当前存在事务，把当前事务挂起。

***PROPAGATION_NOT_SUPPORTED***--以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
--- 如果当前有事务，就是以非事务进行执行

***PROPAGATION_NEVER***--以非事务方式执行，如果当前存在事务，则抛出异常。

默认传播行为为REQUIRED

#### 13	Spring事务隔离级别？

**四种隔离级别**

1. DEFAULT
   默认隔离级别，每种数据库支持的事务隔离级别不一样，如果Spring配置事务时将isolation设置为这个值的话，那么将使用底层数据库的默认事务隔离级别。顺便说一句，如果使用的MySQL，可以使用"select @@tx_isolation"来查看默认的事务隔离级别

2. READ_UNCOMMITTED
   读未提交，即能够读取到没有被提交的数据，所以很明显这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用

3. READ_COMMITED

   读已提交，即能够读到那些已经提交的数据，自然能够防止脏读，但是无法限制不可重复读和幻读

4. REPEATABLE_READ
   重复读取，即在数据读出来之后加锁，类似"select * from XXX for update"，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决

5. SERLALIZABLE
   串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了

#### 14	事务并发问题：脏读，幻读，不可重复读？

1. 脏读
   所谓脏读，就是指事务A读到了事务B还没有提交的数据，比如银行取钱，事务A开启事务，此时切换到事务B，事务B开启事务-->取走100元，此时切换回事务A，事务A读取的肯定是数据库里面的原始数据，因为事务B取走了100块钱，并没有提交，数据库里面的账务余额肯定还是原始余额，这就是脏读。

2. 不可重复读
   所谓不可重复读，就是指在一个事务里面读取了两次某个数据，读出来的数据不一致。还是以银行取钱为例，事务A开启事务-->查出银行卡余额为1000元，此时切换到事务B事务B开启事务-->事务B取走100元-->提交，数据库里面余额变为900元，此时切换回事务A，事务A再查一次查出账户余额为900元，这样对事务A而言，在同一个事务内两次读取账户余额数据不一致，这就是不可重复读。

3. 幻读
   所谓幻读，就是指在一个事务里面的操作中发现了未被操作的数据。比如学生信息，事务A开启事务-->修改所有学生当天签到状况为false，此时切换到事务B，事务B开启事务-->事务B插入了一条学生数据，此时切换回事务A，事务A提交的时候发现了一条自己没有修改过的数据，这就是幻读，就好像发生了幻觉一样。幻读出现的前提是并发的事务中有事务发生了插入、删除操作。

#### 15	Spring事务实现原理？

AOP拦截方法+注解+反射机制实现

#### 16	Spring生命周期？

Servlet 加载—>实例化—>服务—>销毁。

#### 17	Spring作用域？

spring 起初的版本只有singleton，也就是单例模式。
作用域包括：
**Singleton**:全局只有一个实例。 

**Prototype**:每次调用产生一个新的实例

**Request**:每次请求产生一个bean

**Session**:每个用户session可以产生一个新的bean，不同用户之间的bean互相不影响

**globalSession**:作用和session类似，只是使用portlet的时候使用。

#### 18	Spring加载bean的过程？(具体的过程要详细描述清楚)

XML文件->Resource->Document->BeanDefinition ->BeanDefinitionMap

#### 19	SpringMVC执行流程？

基于servlet实现
请求->中央控制器 ->处理器映射器 ->处理器适配器 ->Controller 
                               ->视图解析器