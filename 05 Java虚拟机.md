Java虚拟机

#### 1	Java虚拟机结构

Class文件 类加载子系统
方法区  Java堆  Java虚拟机栈 本地方法栈 程序计数器  
即时编译器 垃圾回收器  本地库接口  本地方法库

Java虚拟机内存可以划分为：虚拟机栈、本地方法栈、JAVA堆内存、方法区(包含运行时常量池)、程序计数器、直接内存。其中Java堆和方法区属于公有区域。
1）虚拟机栈
虚拟机栈是线程私有的，生命周期跟线程相同。也就是说一个线程被创建后，虚拟机为其分配了一个独立的栈帧来存储线程的局部变量、操作数、动态链接、方法出口等信息，当线程结束后，该栈帧也会被回收清理。
2）本地方法栈
本地方法栈是虚拟机的native方法执行期间使用的一个栈帧。
3）Java堆
Java堆内存堆内存是被所有线程共享的一块区域，用来存放对象实例和数组，属于内存中最大的一块区域，也是垃圾收集的主要区域。从垃圾收集的角度看，堆内存经常分为新生代和老年代。
4）方法区
方法区方法区也是被所有线程共享的一块区域，用来存储被虚拟机加载的类信息、常量、静态变量、JIT编译后代码等数据。也可以成为永久代。
5）程序计数器
程序计数器是线程私有的，作为当前线程所执行的字节码的行号指示器，每个线程有一个程序计数器，用于记录CPU切换线程时记录当前线程的执行位置，以便下次继续从当前位置往下执行。

#### 2	Java垃圾回收机制。

不定时清理内存中的不可达对象。
System.gc()建议GC进行垃圾回收，但是是否执行，何时执行都是不可知的。
finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。

新生代和老年代：默认新生代和老年代的比例为1:2。即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。
其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。
默认的，Edem : from : to = 8 : 1 : 1 ，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。

#### 3	JVM中查看对象存活

a）引用计数法，GC_Roots引用链法。引用计数法，缺点:循环依赖,如果一个对象没有被任何引用指向。
b）GC_Roots引用链法。基本思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

#### 4	垃圾回收算法

a） 标记-清除算法(Mark-Sweep)
b） 复制算法
c） 标记-整理算法
d） 分代收集算法

标记-清除算法(Mark-Sweep)
       顾名思义，分为标记和清除两个阶段：标记出所有需要回收的对象，然后统一回收所有被标记的对象。缺点：标记和清除的效率都不高，标记清除后会有大量不连续的内存碎片，而过多的内存碎片，会导致后续分配大对象时无法找到足够的连续内存空间，继而触发另一次垃圾回收动作

复制算法(Copying)
       将可用内存分为大小相同两块。每次只用一块，当一块空间用完了，就将还存活的对象复制到另一块上，然后将刚使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。实现简单，运行高效。
优点：算法实现简单，内存效率高，不易产生碎片。
缺点：可用内存被压缩到了原本的一半。且存活对象增多的话，Copying算法的效率会大大降低。

标记-整理(Mark-Compact)
      “标记－整理”（Mark-Compact）算法由于老年代中的对象生存周期都较长，有人提出“标记-整理”算法，标记过程和“标记-清理”一样，但在清除已死对象的同时会对存活对象进行整理，这样可以减少碎片空间。

分代收集算法（Generational Collecting）
       当前商业虚拟机的垃圾收集都是采用分代收集（Generational Collecting）算法，这种算法并没有什么新的思想出现，只是根据对象不同的存活周期将内存划分为几块。一般是把Java堆分作``新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就用复制算法，只要少量复制成本就可以完成收集。而老年代中因为对象的存活率较高、周期长，就用标记-整理或标记-清除算法来回收。
新生代复制回收机制：将新生代区域分为Eden，From Survivor，To Survivor，比例为8:1:1
根据对象的存活周期将内存分为：新生代，老年代，永生代。

#### 5	垃圾收集器

1. Serial收集器
2. ParNew收集器
3. Parallel Scavenge收集器
4. Serial Old收集器
5. Parallel Old收集器
6. CMS收集器
7. G1收集器

1） Serial GC。新生代收集器，采用复制算法，用于Client客户端新生代垃圾收集，针对内存占用较少的应用进行垃圾收集。
2）Serial Old GC。老年代收集器，采用标记-整理算法，用于Client客户端老年代垃圾收集，针对内存占用较少的应用进行垃圾收集。
3） Parallel Scavenge GC。新生代收集器，采用复制算法，并行收集新生代内存垃圾，可以设置垃圾收集器的吞吐量，还可以设置自动适配调节吞吐量。
4）Parallel New GC。新生代收集器，采用复制算法，并行收集新生代内存垃圾。
5）Parallel Old GC。老年代收集器，采用标记-整理算法，并行收集老年代内存垃圾。
6）CMS GC。老年代收集器，采用标记-清除算法，并行收集老年代内存垃圾，不整理内存。由于在执行垃圾收集期间不中断业务线程，所以容易产出“浮动垃圾”，导致Full GC。可以通过设置参数来触发内存整理任务。
7）G1 GC。不再将堆内存区分新生代和老年代，而是将堆内存看作若干个均分小区域，并对最空闲的内存区域进行标记和回收。适用于大内存的应用。

#### 6	JVM参数设置性能调优

常见参数配置
-XX:+PrintGC            每次触发GC的时候打印相关日志
-XX:+UseSerialGC     串行回收
-XX:+PrintGCDetails  更详细的GC日志
-Xms                           堆初始值
-Xmx                           堆最大可用值
-Xmn                           新生代堆最大可用值
-XX:NewRatio             配置新生代与老年代占比 1:2
-XX:SurvivorRatio=eden/from=eden/to
-XX:SurvivorRatio        用来设置新生代中eden空间和from/to空间的比例.
总结:在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，
这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。

性能调优策略：减少垃圾回收，垃圾回收的时候会导致其他工作线程暂停，影响性能。
具体方法：
1）堆初始值 等于 堆最大值
2）设置新生代和老年代比例为1:2

初始堆值和最大堆内存内存越大，吞吐量就越高。
最好使用并行收集器,因为并行收集器速度比串行吞吐量高，速度快。
设置堆内存新生代的比例和老年代的比例最好为1:2或者1:3。
减少GC对老年代的回收。

#### 7	JDK 可视化工具

Jconsole visualVM

#### 8 	Java虚拟机类加载器。

1）Bootstrap类加载器(启动类加载器)-----JRE/lib/rt.jar
2）Extension类加载器(扩展类加载器)-----JRE/lib/ext或者java.ext.dirs指向的目录
3）Application类加载器(应用程序类加载器)------ClassPath环境变量.由-classpath或-cp选项来定义.或者是jar中的Manifest的classpath属性定义.

#### 9	类加载器的工作原理。(双亲委派模型)

类加载器的工作原理基于三个机制：委托、可见性和单一性.
1）委托机制
当一个类加载和初始化的时候.类仅在有需要加载的时候被加载.假设你有一个应用需要的类叫做“Abc.class”.首先加载这个类的请求由Application类加载器委托给它的父加载器Extension类加载器.然后再委托Bootstrap类加载器.Bootstrap类加载器会先看看rt.jar中有没有这个类.因为并没有这个类.所以这个请求又回到Extension加载器.它会查看jre/lib/ext目录下有没有这个类.如果有这个类.那么它将被加载.而Application类加载器不会加载到这个类.如果这个类没有被Extension类加载器找到.那么由Application加载器从classpath中寻找.记住classpath定义的是类文件的加载目录.而PATH定义的是可执行程序.如javac、java等的执行路径.
2）可见性机制
根据可见性机制.子类加载器可以看到父加载器加载的类.而反之则不行.所以下面的例子中.当Abc.class已经被Application类加载器加载过了.然后如果想要使用Extension类加载器加载这个类.将会抛出java.lang.ClassNotFoundException异常.
3）单一性机制
根据这个机制.父加载器加载过的类不能被子加载器加载第二次.虽然重写违反委托和单一性机制的类加载器是可能的.但这样做并不可取.

#### 10	类加载过程。

类从被加载到虚拟机内存中开始.到卸载出内存为止.它的整个生命周期包括为：**加载**、**连接**（验证、准备、解析）、**初始化**、**使用**和**卸载**7个阶段.
 1、加载
加载是“类加载”过程的一个阶段.在加载阶段.虚拟机需要完成以下3件事情.
a）、通过一个类的全限定名来获取定义此类的二进制字节流
b）、在将这个字节流所代表的静态存储结构转化为方法区的运行时的数据结构.
c）、在内存中生成一个代表这个类的java.lang.Class对象.作为方法区这个类的各种数据的访问入口.
2、验证
验证阶段大致上会完成下面4个阶段的检验动作：
1）文件格式验证
2）元数据验证
3）字节码验证
4）符号引用验证
3、准备
准备阶段是正式为类的变量分配内存并设置类变量初始化的阶段.这些变量所使用的内存都将在方法区中进行分配.这个阶段中有两个容易产生混淆的概念.
首先.这时候进行内存分配的仅包括类变量(被static修饰的变量).而不包括实例变量.实例变量将会在对象实例化时随着对象一起分配在java堆中.其次.这里所说的“初始化”在通常情况下是数据类型的零值.
假设一个类变量的定义为： public static int value = 123;
那变量value在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法.而把value赋值为123的putstatic指令是程序被编译后.存放于类构造器<client>()方法之中.所以把value赋值为123的动作在初始化阶段才会执行.或者.我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中.
 4、解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程.
 5、初始化
类初始化阶段是类加载过程中的最后一步.前面的类加载过程中.除了在加载用户应用程序可以通过自定义类加载器去定义之外.其余动作完全由虚拟机主导和控制.到了初始化阶段.才能真正地执行类中定义的java程序代码(或者说是字节码)
准备阶段.变量已经赋过一次系统要求的初始值.而在初始化阶段.则根据程序员通过程序制定的主观计划去初始化类变量和其他资源.或者可以从另外一个角度去表达：初始化阶段是执行类构造器<client>()方法的过程.另外.类构造器<client>()方法和类实例化<init>()方法都是线程安全的.