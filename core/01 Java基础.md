### 1 	线程和进程的区别是什么？


进程是所有线程的集合，每一个线程是进程中的一条执行路径，线程只是一条执行路径。


### 2	Java实现线程有哪几种方式？


   1. 继承Thread类，重写run方法。
   2. 实现Runable接口,重写run。在java8 以后thread类 继承了runable接口。
   3. 使用匿名内部类。
   4. 实现Callable接口通过FutureTask包装器来创建Thread线程


### 3	启动线程方法start()和run()有什么区别？


start()方法开启新的线程，run()只是调用实例方法。


### 4	它们之间如何流转的？


新建状态，就绪状态，运行状态，阻塞状态，死亡状态


### 5	谈谈线程安全问题


当多个线程同时共享，同一个全局变量或静态变量，做写的操作时，可能会发生数据冲突问题，也就是线程安全问题。但是做读操作是不会发生数据冲突问题。


### 6	谈谈Java内存模型

共享内存模型指的就是Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入时,能对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的工作内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。


### 7	什么是死锁？如何避免死锁


同步中嵌套同步,导致锁无法释放。尽量避免同步的相互嵌套。


### 8，线程中的wait()和sleep()方法有什么区别？


wait()释放锁，让线程等待；
sleep()不释放锁。


### 9	Thread Local作用是？


  为线程提供自己的局部变量。Thread Local通过map集合Map.put(“当前线程”,值)；  后面要添加详细的信息


### 10	volatile与synchronized区别是什么？


（1）从而我们可以看出volatile虽然具有可见性但是并不能保证原子性。
（2）性能方面，synchronized关键字是防止多个线程同时执行一段代码，就会影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized。但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。
Volatile保证可见性，把数据刷新到主内存，在某些情况下性能要优于synchronized。
Synchronized既可以保证可见性也可保证原子性。


### 11	线程池的有那些分类？以及使用线程池的好处？


Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：
1. newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
2. newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
3. newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
4. newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序
都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。
第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，
还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。


### 12	线程池实现原理

![](Java笔记-基础.assets/微信图片_20200824143036.png)


1. 当一个任务通过submit或者execute方法提交到线程池的时候，如果当前池中线程数（包括闲置线程）小于coolPoolSize，则创建一个线程执行该任务。

2. 如果当前线程池中线程数已经达到coolPoolSize，则将任务放入等待队列。

3.  如果任务不能入队，说明等待队列已满，若当前池中线程数小于maximumPoolSize，则创建一个临时线程（非核心线程）执行该任务。

4.  如果当前池中线程数已经等于maximumPoolSize，此时无法执行该任务，根据拒绝执行策略处理。

注意：当池中线程数大于coolPoolSize，超过keepAliveTime时间的闲置线程会被回收掉。回收的是非核心线程，核心线程一般是不会回收的。如果设置allowCoreThreadTimeOut(true)，则核心线程在闲置keepAliveTime时间后也会被回收。

### 13	Thread Pool Executor有那些参数

核心线程数 最大线程数 阻塞队列


### 14	你了解那些锁？


重入锁，读写锁，乐观锁，悲观锁
重入锁，也叫做递归锁，指的是一线程 外层代码获得锁之后 ，内层递归仍然有获取该锁的代码，但不受影响。
乐观锁：一种逻辑锁，效率比较高，无阻塞、无等待、重试—CAS无锁机制。通过version版本号 或者 时间戳 做逻辑控制。
悲观锁：属于重量级锁，会阻塞，（行锁，表锁，读锁，写锁）

### 15	你用过那些原子类？

1. AtomicBoolean：原子更新布尔类型。
2. AtomicInteger：原子更新整型。
3. AtomicLong：原子更新长整型。
4. AtomicIntegerArray：原子更新整型数组里的元素。
5. AtomicLongArray：原子更新长整型数组里的元素。
6. AtomicReferenceArray：原子更新引用类型数组里的元素。
7. AtomicReference：原子更新引用类型。
8. AtomicReferenceFieldUpdater：原子更新引用类型里的字段。
9. AtomicMarkableReference：原子更新带有标记位的引用类型。
10. AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。
11. AtomicLongFieldUpdater：原子更新长整型字段的更新器。
12. AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。

底层采用CAS机制


### 16	什么是CAS算法？在多线程中有哪些应用


CAS：Compare and Swap，即比较再交换。
第一，在高并发的情况下，它比有锁的程序拥有更好的性能；
第二，它天生免疫死锁。
就凭借这两个优势，就值得我们冒险尝试使用无锁的并发。


### 17	什么是CAS无锁机制


CAS算法的过程是这样：它包含三个参数CAS(V,E,N): V表示要更新的变量（主内存的值），E表示预期值（工作内存值），N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。


### 18	Lock锁底层原理是什么


AQS  后续补充相关的只是点


### 19	Synchronized底层实现原理？


Synchronized 具有可重入性，保证原子性和可见性，递归锁悲观锁
内存模型 线程可见性重排序 Thradlocal多线程队列 阻塞式和非阻塞式 lock原子类CVS，并发工具类


### 20	集合框架中用到了那些数据结构


数组 链表 二叉树 红黑树


### 21	Array List底层实现原理


底层采用数组和数组扩容技术实现。


### 22	Array List的Add方法实现原理


添加元素后大于当前数组的长度，则进行扩容,将数组的长度增加原来数组的一半。


### 23 	Array List扩容机制原理


添加元素后大于当前数组的长度，则进行扩容,将数组的长度增加原来数组的一半。


### 24 	Array List底层数组默认初始化多少


ArrayList底层默认数组初始化大小为10个object数组


### 25	Vector与Array List区别

Vector是线程安全的，但是性能比Array List要低。
Array List，Vector主要区别为以下几点： 

1. Vector是线程安全的，源码中有很多的synchronized可以看出，而Array List不是。导致Vector效率无法和Array List相比； 
2. Array List和Vector都采用线性连续存储空间，当存储空间不足的时候，Array List默认增加为原来的50%，Vector默认增加为原来的一倍； 
3. Vector可以设置capacity Increment，而Array List不可以，从字面理解就是capacity容量，Increment增加，容量增长的参数。


### 26	Linked List底层实现原理


Linked List底层的数据结构是基于双向循环链表的，且头结点中不存放数据
既然是双向链表，那么必定存在一种数据结构——我们可以称之为节点，
节点实例保存业务数据，前一个节点的位置信息和后一个节点位置信息.


### 27	Linked List与Array List区别

Linked List：底层采用链表结构，在新增和删除的时候不会移动元素，但是在查询的时候需要从first节点一个一个往下面循环遍历，所以Linked List查询效率低，而新增或者删除的效率高。
Array List：底层采用数组结构，新增和删除的时候会移动元素，但是可以根据下标查询，所以ArrayList查询效率高，而新增删除的时候效率低。


### 28	Hash Map实现原理


Hash Map的底层结构是由数组+链表构成的（JDK 1.7）。数组+链表+红黑树（JDK  1.8）。


### 29	Hash Map Hash碰撞问题如何解决的？


解决hash冲突，不同的key映射到了数组的同一索引处，则形成链表。


### 30	Hash Map 1.7实现与1.8实现的区别


1.8 数组+链表+红黑树
1.7 数组+链表 


### 31	Hash Map负载因子的作用是什么？


0.75扩容预警实际数组大小 负载因子越小 hash冲突就越小


### 32	Hash Map底层扩容机制实现原理？


链表越长，节点越多，查询效率越低。
链表查询效率低，最好减少hash碰撞的问题，最好直接采用hash获取到index（无hash碰撞）。
Hashcode形同，但是扩容后长度发生变化，重新计算index()。


### 33	Hash Code和Equals区别？


 1. equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。
 2. hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。


### 34	Hash Map容量为2的n次方，每次扩容为原容量的2倍？


当前size大小大达到 容量*负载因子时，就会进行扩容，hashmap新的容量为原容量的2倍，
至于扩容为原来的2倍，目的是为了老数据的迁移。


### 35	String的Hash Code方法。


1. 31是一个不大不小的质数，哈希冲突更小，大致均匀分布int的范围内。
2. 31可以被 JVM 优化，31 * i = (i << 5) - i。


### 36 	Hash Map的工作原理


1.	默认容量16，负载因子0.75，数组+链表（红黑树）的散列桶（bucket）
2.	执行put过程
    2.1 根据 key计算hash值(h = key.hashCode()) ^ (h >>> 16),再计算下标 i = (n - 1) & hash
    2.2 如果没有遇到碰撞（hash值相同），则放入桶。遇到碰撞，则以链表方式存入后面
    2.3 如果链表长度超过阈值( TREEIFY_THRESHOLD=8)，并且节点容量超过（MIN_TREEIFY_CAPACITY=64），就把链表		转成红黑树，链表长度低于阈值(UNTREEIFY_THRESHOLD=6)，就把红黑树转回链表
    2.4 如果节点已经存在，则替换旧值
    2.5 如果桶满了（容量*负载因子），就需要 resize（扩容2倍重排）
3.	执行get过程
    3.1 根据key计算hash值，再计算下标，找到对应的桶。
    3.2 比较第一个节点的key，如果key相同则返回
    3.3 如果第一个节点的key不相同，存在下一个节点，如果是TreeNode，那么在红黑树中查找相同key的节点，否则，在	链表中查找相同key的节点


### 37 	Java面向对象的基本原则


1. 单一职责原则：一个类只做它该做的事情。
2. 开闭原则：软件实体应当对扩展开放，对修改关闭。
3. 依赖倒转原则：面向接口编程。
4. 里氏替换原则：任何时候都可以用子类型替换掉父类型。
5. 接口隔离原则：接口要小而专，绝不能大而全。
6. 合成聚合复用原则：优先使用聚合或合成关系复用代码。
7. 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。


