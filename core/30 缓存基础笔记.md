## 缓存相关基础

#### 1	什么是Ehcache

 Ehcache是纯java的开源缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。它主要面向通用缓

存、Java EE和轻量级容器，具有内存和磁盘存储、缓存加载器、缓存扩展、缓存异常处理程序。 

Ehcache 被广泛用于在Hibernate、Spring、Cocoon等其他开源系统。

Ehcache的主要特性

1. 快速；

2. 简单；

3. 多种缓存策略；

4. 缓存数据有两级：内存和磁盘，因此无需担心容量问题；

5. 缓存数据会在虚拟机重启的过程中写入磁盘；

6. 可以通过 RMI、可插入 API 等方式进行分布式缓存；

7. 具有缓存和缓存管理器的侦听接口；

8. 支持多缓存管理器实例，以及一个实例的多个缓存区域；



#### 2	Ehcache使用介绍

​       Ehcache是用来管理缓存的一个工具，其缓存的数据可以是存放在内存里面的，也可以是存放在硬盘上的。其核心是

Cache Manager，一切Ehcache的应用都是从Cache Manager开始的。它是用来管理Cache（缓存）的，一个应用可以有

多个Cache Manager，而一个Cache Manager下又可以有多个Cache。Cache内部保存的是一个个的Element，而一个

Element中保存的是一个key和value的配对，相当于Map里面的一个Entry。

#### 3	Ehcache的使用场景

使用纯java的ehcache作为本地缓存

Reids 作为远程分布式缓存

解决Redis缓存压力过大，提高缓存速度，以及缓存性能。

#### 4	Redis和Ehcache缓存的区别

如果是单个应用或者对缓存访问要求很高的应用，用Ehcache。

如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用Redis。

#### 5	什么是Redis

Redis是由意大利人Salvatore Sanfilippo 开发的一款内存高速缓存数据库。Redis全称为：Remote Dictionary Server（远

程数据服务），该软件使用C语言编写，Redis是一个key-value存储系统，它支持丰富的数据类型，如：string、list、

set、zset(sorted set)、hash。

Redis采用的是基于内存的采用的是单进程单线程模型的KV数据库，由C语言编写。官方提供的数据是可以达到

100000+的QPS，是一个非关系行数据库，以key-value方式进行存储，Redis单线程方式存储，保证线程安全。

#### 6	Redis单线程好处

代码更清晰，处理逻辑更简单 

不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗

不存在多进程或者多线程导致的切换而消耗CPU

所以Redis线程是安全的

#### 7	Redis 应用场景：

1. 令牌生成（临时 有效性）
2. 短息验证码（临时有效性）
3. 热点数据（使用redis减轻数据库压力）
4. 使用reids实现消息中间件（不推荐），发布订阅
5. 分布式锁（ZK或者redis实现分布式锁,redission）
6. 网站计数器

#### 8	Redis基本数据类型

Redis目前支持5种数据类型，分别是：
**String**（字符串）
**List**（列表）
**Hash**（字典）
**Set**（集合）
**Sorted Set**（有序集合）

#### 9	Redis哨兵机制

Redis的哨兵(sentinel) 系统用于管理多个 Redis 服务器,该系统执行以下三个任务:

1）**监控**(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。

2）**提醒**(Notification):当被监控的某个 Redis出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通

知。
3）**自动故障迁移**(Automatic Failover):当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作,它会将

失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master; 当客户端试图连接失效

的Master时,集群也会向客户端返回新Master的地址,使得集群可以使用Master代替失效Master。

哨兵(sentinel) 是一个分布式系统,你可以在一个架构中运行多个哨兵(sentinel) 进程,这些进程使用流言协议来接收关于

Master是否下线的信息,并使用投票协议(agreement protocols)来决定是否执行自动故障迁移,以及选择哪个Slave作为新的

Master.

每个哨兵(sentinel) 会向其它哨兵(sentinel)、master、slave定时发送消息,以确认对方是否”活”着,如果发现对方在指定时间

(可配置)内未回应,则暂时认为对方已挂(所谓的”主观认为宕机” Subjective Down,简称sdown).

若“哨兵群”中的多数sentinel,都报告某一master没响应,系统才认为该master"彻底死亡"(即:客观上的真正down机,Objective 

Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置.

#### 10	Redis 主从复制

将主服务器和从服务器分离，主服务器允许读写操作，从服务器只允许读操作。

主从复制应用场景（集群，多台服务器，读写分离）

#### 11	Redis持久化

**Redis持久化,就是将内存数据保存到硬盘。**

Redis 持久化存储 (**AOF 与 RDB 两种模式**)

1. **RDB持久化**
   **RDB 是以二进制文件，是在某个时间 点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化**

   **的文件，达到数据恢复。**

   优点：使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能

   缺点：RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候

2. **AOF持久化**
   **Append-only file，将“操作 + 数据”以格式化指令的方式追加到操作日志文件的尾部，在 append 操作返回后(已经写入到文件或者即将写入)，才进行实际的数据变更，“日志文件”保存了历史所有的操作过程；当 server 需要数据恢复时，可以直接 replay 此日志文件，即可还原所有的操作过程。**

   AOF 相对可靠，它和 mysql 中 bin.log、apache.log、

   zookeeper 中 txn-log 简直异曲同工。AOF 文件内容是字符串，非常容易阅读和解析。

   **优点**：可以保持更高的数据完整性，如果设置追加 file 的时间是 1s，如果 redis 发生故障，最多会丢失 1s 的数据；

   且如果日志写入不完整支持 redis-check-aof 来进行日志修复；AOF 文件没被 rewrite 之前（文件过大时会对命令进行

   合并重写），可以删除其中的某些命令（比如误操作的 flushall）。

   **缺点**：AOF 文件比 RDB 文件大，且恢复速度慢。

   AOF 默认关闭，开启方法，修改配置文件 reds.conf：appendonly yes。

   

#### 12	AOF与RDB区别

AOF 和 RDB 各有优缺点，这是有它们各自的特点所决定：

1. RDB 是在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数

   据恢复。 

   **优点**：使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能 

   **缺点**：RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更

   适合数据要求不严谨的时候

2. AOF Append-only file，将“操作 + 数据”以格式化指令的方式追加到操作日志文件的尾部，在append操作返回后

   (已经写入到文件或者即将写入)，才进行实际的数据变更，“日志文件”保存了历史所有的操作过程；当server需要

   数据恢复时，可以直接replay此日志文件，即可还原所有的操作过程。AOF相对可靠，它和mysql中bin.log、

   apache.log、zookeeper中txn-log简直异曲同工。AOF文件内容是字符串，非常容易阅读和解析。 

   **优点**：可以保持更高的数据完整性，如果设置追加file的时间是1s，如果redis发生故障，最多会丢失1s的数据；且

   如果日志写入不完整支持redis-check-aof来进行日志修复；AOF文件没被rewrite之前（文件过大时会对命令进行

   合并重写），可以删除其中的某些命令（比如误操作的flushall）。 
   **缺点**：AOF文件比RDB文件大，且恢复速度慢。

#### 13	Redis+ehCache实现两级级缓存

spring boot中集成了spring cache，并有多种缓存方式的实现，如：Redis、Caffeine、JCache、EhCache等等。但如果

只用一种缓存，要么会有较大的网络消耗（如Redis），要么就是内存占用太大（如Caffeine这种应用内存缓存）。在很多

场景下，可以结合起来实现一、二级缓存的方式，能够很大程度提高应用的处理效率。

#### 14	缓存穿透、缓存击穿、缓存雪崩。

**雪崩效应**：由于原有缓存失效（或者数据未加载到缓存中），新缓存未到期间（缓存正常从Redis中获取，如下图）所有

原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机，造成系统

的崩溃。

雪崩解决方案：

使用分布式锁（lock锁）；

使用消息队列；

使用一级缓存和二级缓存；

均摊分配key_value失效时间；

**缓存穿透**：

**缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。**这样就导致用户查询的时候，在缓存中找不到，

每次都要去数据库再查询一遍，然后返回空。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。

解决方案：如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会

继续访问数据库，这种办法最简单粗暴。

**缓存击穿**

 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。

**解决方案**

1. 设置热点数据永远不过期。

2. 加互斥锁。

   

   

#### 15	分布式锁一般有三种实现方式 

1. 数据库乐观锁；
2. 基于Redis的分布式锁；
3. 基于ZooKeeper的分布式锁

分布式锁的优缺点：

1. 采用数据库 不建议 性能不好 。
2. 基于Redis实现分布式锁（setnx）setnx也可以存入key，如果存入key成功返回1，如果存入的key已经存在了，返回0。
3. 基于Zookeeper实现分布式锁 Zookeeper是一个分布式协调工具，在分布式解决方案中。
   多个客户端（jvm），同时在zk上创建相同的一个临时节点，因为临时节点路径是保证唯一，只要谁能够创建节点成功，谁就能够获取到锁，没有创建成功节点，就会进行等待，当释放锁的时候，采用事件通知给客户端重新获取锁的资源。

#### 16  分布式锁获取锁、释放锁、死锁问题？

**获取锁**

1. Zookeeper，多个客户端（jvm），会在Zookeeper上创建同一个临时节点，因为Zookeeper节点命名路径保证唯一，不允许出现重复，只要谁能够先创建成功，谁能够获取到锁。
2. Redis，多个客户端（jvm），会在Redis使用setnx命令创建相同的一个key，因为Redis的key保证唯一，不允许出现重复，只要谁能够先创建成功，谁能够获取到锁。

**释放锁**

1. Zookeeper使用直接关闭临时节点session会话连接，因为临时节点生命周期与session会话绑定在一块，如果session会话连接关闭的话，该临时节点也会被删除。
   这时候客户端使用事件监听，如果该临时节点被删除的话，重新进入盗获取锁的步骤。
2. Redis在释放锁的时候，为了确保是锁的一致性问题，在删除的redis 的key时候，需要判断同一个锁的id，才可以删除。

共同特征：如何解决死锁现象问题

1. Zookeeper使用会话有效期方式解决死锁现象。
2. Redis 是对key设置有效期解决死锁现象

**性能分析：**

1. 性能角度考虑。因为Redis是NoSQL数据库，相对比来说Redis比Zookeeper性能要好。
2. 可靠性角度考虑。
   从可靠性角度分析，Zookeeper可靠性比Redis更好。
   因为Redis有效期不是很好控制，可能会产生有效期延迟，Zookeeper就不一样，因为Zookeeper临时节点先天性可控的有效期，所以相对来说Zookeeper比Redis更好。